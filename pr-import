#!/usr/bin/env bash
set -euo pipefail

###
# pr-import: importar un PR del repo original (upstream) hacia tu fork
# Usa GitHub CLI + git. Soporta modos: interactivo, no interactivo y dry-run.
###

# Mostrar ayuda / uso
function show_help() {
  cat <<EOF
Uso: pr-import [opciones]

Este script ayuda a importar Pull Requests (PR) de un repo original (upstream)
a tu fork, creando una rama local temporal y luego un PR en el fork.

Opciones:
  -h, --help                Muestra este mensaje de ayuda y sale.
  -u, --upstream UPSTREAM   Repositorio original (upstream) en formato owner/repo.
  -f, --fork FORK           Tu fork en formato owner/repo.
  -d, --dir LOCAL_DIR       Directorio local donde clonar el fork. (por defecto, el directorio actual)
  -p, --pr PR_NUM           Número del PR en el repositorio original.
  -b, --branch TARGET       Rama destino en tu fork para aplicar el PR.
  -n, --non-interactive     Modo no interactivo (no pedir input).
  -r, --dry-run             Modo dry-run: simula las acciones sin ejecutarlas.

Ejemplos:
  pr-import -u "owner/repo" -f "miusuario/repo" -d "." -p 123 -b "main"
  pr-import -n -r -u "owner/repo" -f "miusuario/repo" -d "." -p 123 -b "main"  # no interactivo + simulación
EOF
}

# Primero, si se pide ayuda
if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
  show_help
  exit 0
fi

# Directorio base (donde ejecutas el script)
BASE_DIR="$(pwd)"
CONF_FILE="${BASE_DIR}/pr_import.conf"
LOG_FILE="${BASE_DIR}/pr_import.log"

# Flags
NON_INTERACTIVE=false
DRY_RUN=false

# Función de log
function log() {
  local ts
  ts=$(date +"%Y-%m-%d %H:%M:%S")
  echo "[$ts] $*" >> "$LOG_FILE"
}

# Cargar configuración si existe
function load_config() {
  if [ -f "$CONF_FILE" ]; then
    # shellcheck disable=SC1090
    source "$CONF_FILE"
    log "Configuración cargada desde $CONF_FILE"
  fi
}

# Guardar configuración
function save_config() {
  cat > "$CONF_FILE" <<EOF
# Configuración generada por pr-import
UPSTREAM_REPO="${UPSTREAM_REPO:-}"
FORK_REPO="${FORK_REPO:-}"
LOCAL_DIR="${LOCAL_DIR:-}"
EOF
  chmod 600 "$CONF_FILE"
  log "Configuración guardada en $CONF_FILE"
}

# Asegurar que .gitignore existe y contiene conf + log
function ensure_gitignore_entries() {
  local gi_file="${BASE_DIR}/.gitignore"
  local conf_name="pr_import.conf"
  local log_name="pr_import.log"

  if [ ! -f "$gi_file" ]; then
    touch "$gi_file"
    log "Creado .gitignore en ${gi_file}"
  fi

  if ! grep -Fxq "$conf_name" "$gi_file"; then
    echo "$conf_name" >> "$gi_file"
    log "Agregado $conf_name a .gitignore"
  fi

  if ! grep -Fxq "$log_name" "$gi_file"; then
    echo "$log_name" >> "$gi_file"
    log "Agregado $log_name a .gitignore"
  fi
}

# Uso breve (fallback)
function usage() {
  echo "Uso: $0 [-u UPSTREAM_REPO] [-f FORK_REPO] [-d LOCAL_DIR] [-p PR_NUM] [-b TARGET_BRANCH] [-n] [-r]"
  exit 1
}

# Procesar opciones / flags
while getopts "u:f:d:p:b:n:r" opt; do
  case $opt in
    u) UPSTREAM_REPO=$OPTARG ;;
    f) FORK_REPO=$OPTARG ;;
    d) LOCAL_DIR=$OPTARG ;;
    p) PR_NUM=$OPTARG ;;
    b) TARGET_BRANCH=$OPTARG ;;
    n) NON_INTERACTIVE=true ;;
    r) DRY_RUN=true ;;
    *) usage ;;
  esac
done

# Si modo no interactivo, primero cargar config
if [ "$NON_INTERACTIVE" = true ]; then
  load_config
fi

# Pedir valores si faltan (modo interactivo)
if [ -z "${UPSTREAM_REPO:-}" ]; then
  read -rp "Ingresa repo original (upstream) owner/repo: " UPSTREAM_REPO
fi
if [ -z "${FORK_REPO:-}" ]; then
  read -rp "Ingresa tu fork owner/repo: " FORK_REPO
fi
if [ -z "${LOCAL_DIR:-}" ]; then
  # Pregunta con sugerencia: "." significa el directorio actual
  read -rp "Ingresa directorio local donde clonar el fork (por defecto \".\"): " LOCAL_DIR
  if [ -z "$LOCAL_DIR" ]; then
    LOCAL_DIR="."
  fi
fi
if [ -z "${PR_NUM:-}" ]; then
  read -rp "Ingresa número del PR en upstream: " PR_NUM
fi

# Antes de pedir TARGET_BRANCH, necesitamos mostrar las ramas del fork
# Pero para eso primero debemos clonar / fetch para tener datos

# Si modo no interactivo, guardar config ahora (para tener repos + local dir)
if [ "$NON_INTERACTIVE" = true ]; then
  save_config
fi

# Asegurar .gitignore
ensure_gitignore_entries

# Función que ejecuta o simula un comando (depende de DRY_RUN)
function do_cmd() {
  local cmd="$*"
  if [ "$DRY_RUN" = true ]; then
    echo "[DRY-RUN] $cmd"
  else
    log "Ejecución: $cmd"
    eval "$cmd"
  fi
}

# Clonar fork si no existe
if [ ! -d "${LOCAL_DIR}/.git" ]; then
  echo "Clonando fork $FORK_REPO en '$LOCAL_DIR'..."
  do_cmd gh repo clone "$FORK_REPO" "$LOCAL_DIR"
fi

# Entrar al directorio del fork
pushd "$LOCAL_DIR" >/dev/null

# Asegurar remoto upstream
if ! git remote get-url upstream &>/dev/null; then
  echo "Agregando remoto upstream ${UPSTREAM_REPO}..."
  do_cmd git remote add upstream "https://github.com/${UPSTREAM_REPO}.git"
fi

# Fetch de origin y upstream
do_cmd git fetch origin
do_cmd git fetch upstream

# Ahora sí listar ramas del fork (origin)
mapfile -t branches < <(git branch -r | grep "^origin/" | sed 's|origin/||' | sort | uniq)
if [ "${#branches[@]}" -eq 0 ]; then
  echo "Error: no encontré ramas en el fork (origin)" >&2
  popd >/dev/null
  exit 1
fi

if [ -z "${TARGET_BRANCH:-}" ]; then
  # Mostrar listado de ramas al usuario
  echo "Ramas disponibles en el fork (origin):"
  local i=1
  for br in "${branches[@]}"; do
    echo "  $i) $br"
    (( i++ ))
  done
  read -rp "Selecciona con número la rama destino en tu fork: " sel
  if ! [[ "$sel" =~ ^[0-9]+$ ]]; then
    echo "Selección inválida: $sel" >&2
    popd >/dev/null
    exit 1
  fi
  if [ "$sel" -lt 1 ] || [ "$sel" -gt "${#branches[@]}" ]; then
    echo "Selección fuera de rango: $sel" >&2
    popd >/dom/null
    exit 1
  fi
  TARGET_BRANCH="${branches[$((sel-1))]}"
fi

# Traer la rama del PR desde upstream
pr_branch="pr-${PR_NUM}"
# Si ya existe local la rama pr-<num>, eliminarla para evitar conflictos
if git show-ref --verify --quiet "refs/heads/${pr_branch}"; then
  do_cmd git branch -D "${pr_branch}"
fi

echo "Traendo PR #${PR_NUM} desde upstream..."
do_cmd git fetch upstream "pull/${PR_NUM}/head:${pr_branch}"

# Cambiar a esa rama local
do_cmd git checkout "${pr_branch}"
do_cmd git pull --ff-only || true

# Push de la rama al fork
echo "Pushing rama ${pr_branch} al fork..."
do_cmd git push origin "${pr_branch}"

# Crear el PR en el fork usando gh, con fallback si --fill falla
function create_pr_in_fork() {
  local pr_num=$1
  local pr_branch=$2
  local target_branch=$3
  local fork_user="${FORK_REPO%%/*}"
  local PR_URL

  echo "Creando PR en el fork..."
  if PR_URL=$(gh pr create \
       --base "${target_branch}" \
       --head "${fork_user}:${pr_branch}" \
       --fill \
       --repo "${FORK_REPO}" 2>/dev/null); then
    :
  else
    echo "Advertencia: gh pr create con --fill falló; intentando fallback..."
    # Fallback: usar título / cuerpo explícitos
    local fallback_title="Import PR #${pr_num} from upstream"
    local fallback_body="Importado automáticamente del PR #${pr_num} del repositorio upstream."
    PR_URL=$(gh pr create \
      --base "${target_branch}" \
      --head "${fork_user}:${pr_branch}" \
      --title "${fallback_title}" \
      --body "${fallback_body}" \
      --repo "${FORK_REPO}") || {
      echo "Error: creación de PR falló (fallback también)" >&2
      log "ERROR: gh pr create fallback falló"
      popd >/dev/null
      exit 1
    }
  fi

  echo "$PR_URL"
}

# Llamar a la función para crear PR (o simular)
if [ "$DRY_RUN" = true ]; then
  echo "[DRY-RUN] gh pr create --base ${TARGET_BRANCH} --head ${FORK_REPO%%/*}:${pr_branch} --fill --repo ${FORK_REPO}"
  PR_URL="(simulado)"
else
  PR_URL=$(create_pr_in_fork "${PR_NUM}" "${pr_branch}" "${TARGET_BRANCH}")
fi

popd >/dev/null

echo "✅ PR (o simulación) completado: ${PR_URL}"
log "PR resultado: ${PR_URL}"
